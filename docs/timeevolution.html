

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Time-evolution &mdash; QuantumOptics.jl</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="QuantumOptics.jl" href="index.html"/>
        <link rel="next" title="Steady state" href="steadystate.html"/>
        <link rel="prev" title="N-Particles Basis" href="nparticles.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> QuantumOptics.jl
          

          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="states.html">States and Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantumsystems.html">Quantum systems</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Time-evolution</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#schroedinger-time-evolution">Schroedinger time evolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#master-time-evolution">Master time evolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mcwf-time-evolution">MCWF time evolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-examples">Advanced examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="steadystate.html">Steady state</a></li>
<li class="toctree-l1"><a class="reference internal" href="correlations.html">Two-time correlation functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="spectralanalysis.html">Spectral Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="superoperators.html">Super-operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="bases.html">Bases</a></li>
<li class="toctree-l1"><a class="reference internal" href="operators.html">Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">QuantumOptics.jl</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Time-evolution</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/timeevolution.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="time-evolution">
<span id="section-timeevolution"></span><h1>Time-evolution<a class="headerlink" href="#time-evolution" title="Permalink to this headline">¶</a></h1>
<p><strong>QuantumOptics.jl</strong> implements solver for dynamics of closed and open quantum systems:</p>
<ul class="simple">
<li><a class="reference internal" href="#section-schroedinger"><span class="std std-ref">Schroedinger equation</span></a></li>
<li><a class="reference internal" href="#section-master"><span class="std std-ref">Master equation</span></a></li>
<li><a class="reference internal" href="#section-mcwf"><span class="std std-ref">Monte Carlo wave function method (MCWF)</span></a></li>
</ul>
<p>The interfaces are designed to be as consistent as possible to make it easy to switch between different methods.</p>
<div class="section" id="schroedinger-time-evolution">
<span id="section-schroedinger"></span><h2>Schroedinger time evolution<a class="headerlink" href="#schroedinger-time-evolution" title="Permalink to this headline">¶</a></h2>
<p>The Schroedinger equation as one of the basic postulates of quantum mechanics describes the dynamics of a quantum state in a closed quantum system. In Dirac notation the Schroedinger equation and its adjoint equation read</p>
<div class="math">
\[ \begin{align}\begin{aligned}i\hbar\frac{\mathrm{d}}{\mathrm{d} t} |\Psi(t)\rangle = H |\Psi(t)\rangle\\- i\hbar\frac{\mathrm{d}}{\mathrm{d} t} \langle \Psi(t)| = \langle\Psi(t)| H\end{aligned}\end{align} \]</div>
<p>Both versions are implemented and are chosen automatically depending on the type of the provided initial state (Bra or Ket):</p>
<ul class="simple">
<li><code class="xref jl jl-func docutils literal"><span class="pre">schroedinger(tspan::Vector{Float64},</span> <span class="pre">psi0::{Ket,Bra},</span> <span class="pre">H::Operator)</span></code></li>
</ul>
<p>The Schrödinger equation solver requires the arguments <code class="xref jl jl-func docutils literal"><span class="pre">tspan</span></code>, which is a vector containing the times, the initial state <code class="xref jl jl-func docutils literal"><span class="pre">psi0</span></code>
as <code class="xref jl jl-func docutils literal"><span class="pre">Ket</span></code> or <code class="xref jl jl-func docutils literal"><span class="pre">Bra</span></code> and the Hamiltonian <code class="xref jl jl-func docutils literal"><span class="pre">H</span></code>.</p>
<p>Additionally, one can pass an output function <code class="xref jl jl-func docutils literal"><span class="pre">fout</span></code> as keyword argument. This can be convenient if one directly wants to compute a value that depends on the states, e.g. an expectation value, instead
of the states themselves. Consider, for example, a time evolution according to a Schrödinger equation where for all times we want to compute the expectation value of the operator <code class="xref jl jl-func docutils literal"><span class="pre">A</span></code>. We can do this by:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">tout</span><span class="p">,</span> <span class="n">psi_t</span> <span class="o">=</span> <span class="n">timeevolution</span><span class="o">.</span><span class="n">schroedinger</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
<span class="n">exp_val</span> <span class="o">=</span> <span class="n">expect</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)</span>
</pre></div>
</div>
<p>or equivalently:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">tout</span> <span class="o">=</span> <span class="kt">Float64</span><span class="p">[]</span>
<span class="n">exp_val</span> <span class="o">=</span> <span class="kt">Complex128</span><span class="p">[]</span>
<span class="k">function</span> <span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi</span><span class="p">)</span>
  <span class="n">push!</span><span class="p">(</span><span class="n">tout</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
  <span class="n">push!</span><span class="p">(</span><span class="n">exp_val</span><span class="p">,</span> <span class="n">expect</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi</span><span class="p">)</span>
<span class="k">end</span>
<span class="n">timeevolution</span><span class="o">.</span><span class="n">schroedinger</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">H</span><span class="p">;</span> <span class="n">fout</span><span class="o">=</span><span class="n">exp</span><span class="p">)</span>
</pre></div>
</div>
<p>Although the method using <code class="xref jl jl-func docutils literal"><span class="pre">fout</span></code> might seem more complicated, it can be very useful for large systems to save memory since instead of all the states we only store one complex number per time step. Note, that
<code class="xref jl jl-func docutils literal"><span class="pre">fout</span></code> must always be defined with the arguments <code class="xref jl jl-func docutils literal"><span class="pre">(t,</span> <span class="pre">psi)</span></code>. If <code class="xref jl jl-func docutils literal"><span class="pre">fout</span></code> is given, all variables are assigned within <code class="xref jl jl-func docutils literal"><span class="pre">fout</span></code> and the call to <a class="reference internal" href="api.html#schroedinger-3b7c668082c5d4d079c52549b66d6d1d" title="schroedinger"><code class="xref jl jl-func docutils literal"><span class="pre">schroedinger</span></code></a>
returns <code class="xref jl jl-func docutils literal"><span class="pre">nothing</span></code>.</p>
<p>We can also calculate the time evolution for a Hamiltonian that is time-dependent. In that case, we need to use the function <code class="xref jl jl-func docutils literal"><span class="pre">schroedinger_dynamic(tspan,</span> <span class="pre">psi0,</span> <span class="pre">f::Function)</span></code>. As you can see, this function
requires the same arguments as <a class="reference internal" href="api.html#schroedinger-3b7c668082c5d4d079c52549b66d6d1d" title="schroedinger"><code class="xref jl jl-func docutils literal"><span class="pre">schroedinger</span></code></a>, but a function <code class="xref jl jl-func docutils literal"><span class="pre">f</span></code> instead of a Hamiltonian. As a brief example, consider a spin-1/2 particle that is coherently driven by a laser that has an amplitude that
varies in time. We can implement this with:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">basis</span> <span class="o">=</span> <span class="n">SpinBasis</span><span class="p">(</span><span class="mi">1</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ψ₀</span> <span class="o">=</span> <span class="n">spindown</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
<span class="k">function</span> <span class="n">pump</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">sigmap</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="o">+</span> <span class="n">sigmam</span><span class="p">(</span><span class="n">basis</span><span class="p">))</span>
<span class="k">end</span>
<span class="n">tspan</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mf">0.1</span><span class="o">:</span><span class="mi">10</span><span class="p">;]</span>
<span class="n">tout</span><span class="p">,</span> <span class="n">ψₜ</span> <span class="o">=</span> <span class="n">timeevolution</span><span class="o">.</span><span class="n">schroedinger_dynamic</span><span class="p">(</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ψ₀</span><span class="p">,</span> <span class="n">pump</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="master-time-evolution">
<span id="section-master"></span><h2>Master time evolution<a class="headerlink" href="#master-time-evolution" title="Permalink to this headline">¶</a></h2>
<p>The dynamics of open quantum systems are governed by a master equation in Lindblad form:</p>
<div class="math">
\[\dot{\rho} = -\frac{i}{\hbar} \big[H,\rho\big]
             + \sum_i \big(
                    J_i \rho J_i^\dagger
                    - \frac{1}{2} J_i^\dagger J_i \rho
                    - \frac{1}{2} \rho J_i^\dagger J_i
                \big)\]</div>
<p>It is implemented by the function</p>
<ul class="simple">
<li><a class="reference internal" href="api.html#master-ba24c2fffbe32ab8cb2efcd34a0bbe8b" title="master(tspan, rho0::DenseOperator, H::Operator, J::Vector)"><code class="xref jl jl-func docutils literal"><span class="pre">master(tspan,</span> <span class="pre">rho0::DenseOperator,</span> <span class="pre">H::Operator,</span> <span class="pre">J::Vector)</span></code></a></li>
</ul>
<p>The arguments required are quite similar to the ones of <a class="reference internal" href="api.html#schroedinger-3b7c668082c5d4d079c52549b66d6d1d" title="schroedinger"><code class="xref jl jl-func docutils literal"><span class="pre">schroedinger</span></code></a>. <code class="xref jl jl-func docutils literal"><span class="pre">tspan</span></code> is a vector of times, <code class="xref jl jl-func docutils literal"><span class="pre">rho0</span></code> the initial state and <code class="xref jl jl-func docutils literal"><span class="pre">H</span></code> the Hamiltonian. We now also need the vector <code class="xref jl jl-func docutils literal"><span class="pre">J</span></code>
that specifies the jump operators of the system.</p>
<p>The additional arguments available are</p>
<ul class="simple">
<li><code class="xref jl jl-func docutils literal"><span class="pre">Gamma::{Vector{Float64},</span> <span class="pre">Matrix{Float64}}</span></code></li>
<li><code class="xref jl jl-func docutils literal"><span class="pre">Jdagger::Vector</span></code></li>
<li><code class="xref jl jl-func docutils literal"><span class="pre">fout::Function</span></code></li>
</ul>
<p>The first specifies the decay rates of the system with default values one. If <code class="xref jl jl-func docutils literal"><span class="pre">Gamma</span></code> is a vector of length <code class="xref jl jl-func docutils literal"><span class="pre">length(J)</span></code>, then the <cite>i</cite> th entry of <code class="xref jl jl-func docutils literal"><span class="pre">Gamma</span></code> is paired with the <cite>i</cite> th entry of <code class="xref jl jl-func docutils literal"><span class="pre">J</span></code>, such
that <span class="math">\(J_i\)</span> decays with <span class="math">\(\gamma_i\)</span>. If, on the other hand, <code class="xref jl jl-func docutils literal"><span class="pre">Gamma</span></code> is a matrix, then all entries of <code class="xref jl jl-func docutils literal"><span class="pre">J</span></code> are paired with one another and matched with the corresponding entrie of <code class="xref jl jl-func docutils literal"><span class="pre">Gamma</span></code>, resulting
in a Lindblad term of the form <span class="math">\(\sum_{i,j}\gamma_{ij}J_i\rho J_j^\dagger - J_i^\dagger J_j\rho/2 - \rho J_i^\dagger J_j/2\)</span>.</p>
<p>The second keyword argument can be used to pass a specific set of jump operators to be used in place of all <span class="math">\(J^\dagger\)</span> appearances in the Lindblad term.</p>
<p>We can pass an output function just like the one for a Schrödinger equation. Note, though, that now the function must be defined with the arguments <code class="xref jl jl-func docutils literal"><span class="pre">fout(t,</span> <span class="pre">rho)</span></code>.</p>
<p>Furthermore, a time-dependent Hamiltonian can also be implemented analogously to a Schrödinger equation using <code class="xref jl jl-func docutils literal"><span class="pre">master_dynamic(tspan,</span> <span class="pre">rho0,</span> <span class="pre">f)</span></code>.</p>
<p>For performance reasons the solver internally first creates the non-hermitian Hamiltonian <span class="math">\(H_\mathrm{nh} = H - \frac{i\hbar}{2} \sum_i J_i^\dagger J_i\)</span> and solves the equation</p>
<div class="math">
\[\dot{\rho} = -\frac{i}{\hbar} \big[H_\mathrm{nh},\rho\big]
             + \sum_i J_i \rho J_i^\dagger\]</div>
<p>If for any reason this behavior is unwanted, e.g. special operators are used that don&#8217;t support addition, the function master_h (h for hermitian) can be used.</p>
<ul class="simple">
<li><a class="reference internal" href="api.html#master_h-ba24c2fffbe32ab8cb2efcd34a0bbe8b" title="master_h(tspan, rho0::DenseOperator, H::Operator, J::Vector)"><code class="xref jl jl-func docutils literal"><span class="pre">master_h(tspan,</span> <span class="pre">rho0::DenseOperator,</span> <span class="pre">H::Operator,</span> <span class="pre">J::Vector)</span></code></a></li>
<li><a class="reference internal" href="api.html#master_nh-436e712c6a9ad68f0e9d4fe90930eb2d" title="master_nh(tspan, rho0::DenseOperator, Hnh::Operator, J::Vector)"><code class="xref jl jl-func docutils literal"><span class="pre">master_nh(tspan,</span> <span class="pre">rho0::DenseOperator,</span> <span class="pre">Hnh::Operator,</span> <span class="pre">J::Vector)</span></code></a></li>
</ul>
</div>
<div class="section" id="mcwf-time-evolution">
<span id="section-mcwf"></span><h2>MCWF time evolution<a class="headerlink" href="#mcwf-time-evolution" title="Permalink to this headline">¶</a></h2>
<p>Instead of solving the Master equation</p>
<div class="math">
\[\dot{\rho} = -\frac{i}{\hbar} \big[H,\rho\big]
             + \sum_i \big(
                    J_i \rho J_i^\dagger
                    - \frac{1}{2} J_i^\dagger J_i \rho
                    - \frac{1}{2} \rho J_i^\dagger J_i
                \big)\]</div>
<p>directly, one can use the quantum jump formalism to evaluate single stochastic quantum trajectories using the Monte Carlo wave function method. For large numbers of trajectories the statistical average then approximates the result of the Master equation. The huge advantage is that instead of describing the state of the quantum system by a density matrix of size <span class="math">\(N^2\)</span> these trajectories work in terms of state vectors of size <span class="math">\(N\)</span>. This is somewhat negated by the stochastic nature of the formalism which makes it necessary to repeat the simulation until the wanted accuracy is reached. It turns out, however, that for many cases, especially for high dimensional quantum systems, the necessary number of repetitions is much smaller than the system size <span class="math">\(N\)</span> and therefore using the MCWF method is advantageous.</p>
<p>Additionally this quantum jump formalism also has a very intuitive physical interpretation. It basically describes the situation where every quantum jump, e.g. the emission of a photon, is detected by a detector and therefore the time evolution can be completely reconstructed by an outside observer. Depending on the efficiency of the used detectors this might be a much better description for an actual experiment.</p>
<p>This physical picture can be used to easily understand the actual MCWF algorithm:</p>
<ol class="arabic">
<li><p class="first">Calculate coherent time evolution according to a Schroedinger equation with non-hermitian Hamiltonian <span class="math">\(H_\mathrm{nh} = H - \frac{i\hbar}{2} \sum_i J_i^\dagger J_i\)</span></p>
<blockquote>
<div><div class="math">
\[i\hbar\frac{\mathrm{d}}{\mathrm{d} t} |\Psi(t)\rangle = H_\mathrm{nh} |\Psi(t)\rangle\]</div>
</div></blockquote>
</li>
<li><p class="first">Since the Hamiltonian is non-hermitian the norm of the quantum state is not conserved and actually decreases with time. This can be interpreted in the way that the smaller the norm of the state gets the more probable it is that a quantum jump occurs. Quantitatively this means that the coherent time evolution stops when <span class="math">\(\langle \Psi(t)|\Psi(t)\rangle &lt; p\)</span> where <span class="math">\(p\)</span> is a randomly generated number between 0 and 1.</p>
</li>
<li><p class="first">At these randomly determined times a quantum jump according to</p>
<blockquote>
<div><div class="math">
\[|\Psi(t)\rangle \rightarrow \frac{J_i |\Psi(t)\rangle}{||J_i |\Psi(t)\rangle||}\]</div>
<p>is performed.</p>
</div></blockquote>
</li>
<li><p class="first">Continue with coherent time evolution.</p>
</li>
</ol>
<p>The stochastic average of these trajectories is then equal to the solution of the master equation <span class="math">\(\rho(t)\)</span></p>
<div class="math">
\[\lim\limits_{N \rightarrow \infty}\frac{1}{N} \sum_{k=1}^N |\Psi^k(t)\rangle\langle\Psi^k(t)| = \rho(t)\]</div>
<p>and also the stochastic average of the single trajectory expectation values is equal to the expectation value according to the master equation</p>
<div class="math">
\[\lim\limits_{N \rightarrow \infty}\frac{1}{N} \sum_{k=1}^N \langle\Psi^k(t)| A |\Psi^k(t)\rangle = \mathrm{Tr}\big\{A \rho(t)\big\}\]</div>
<p>avoiding explicit calculations of density matrices.</p>
<p>The function computing a time evolution with the MCWF method can be called analogously to <a class="reference internal" href="api.html#master-ba24c2fffbe32ab8cb2efcd34a0bbe8b" title="master"><code class="xref jl jl-func docutils literal"><span class="pre">master</span></code></a>, namely with</p>
<ul class="simple">
<li><a class="reference internal" href="api.html#mcwf-1c364c4da7fc42e70b7eec6b14379f42" title="mcwf(tspan, psi0::Ket, H::Operator, J::Vector)"><code class="xref jl jl-func docutils literal"><span class="pre">mcwf(tspan,</span> <span class="pre">psi0::Ket,</span> <span class="pre">H::Operator,</span> <span class="pre">J::Vector)</span></code></a></li>
</ul>
<p>Since this function only calculates state vectors (as explained above), it requires the initial state in the form of a ket.</p>
</div>
<div class="section" id="advanced-examples">
<h2>Advanced examples<a class="headerlink" href="#advanced-examples" title="Permalink to this headline">¶</a></h2>
<p>This section is meant to provide a basic introduction to the implemented time evolution solvers and illustrate some simple examples.
Most applications of the toolbox involve the simulation of a time evolution in one way or another, so please refer to <a class="reference internal" href="examples.html#section-examples"><span class="std std-ref">Examples</span></a>
for more sophisticated uses of the solvers.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="steadystate.html" class="btn btn-neutral float-right" title="Steady state" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="nparticles.html" class="btn btn-neutral" title="N-Particles Basis" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Sebastian Krämer.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>